《python神经网络编程》读书笔记

# 之一

大约三天读完，这本书浅显易懂，非常适合入门，只有权重调整值的推导过程看得不是很透彻。
## 基本概念
神经网络也是机器学习的一种实现，可以应用在有监督学习和无监督学习，因为中间可以有较多层，所以属于深度学习方法。

神经网络的名字很唬人，其实概念挺朴素的，是由含一个输入层一个输出层和若干隐藏层构成的有向无环图（这名字也唬人），看图像一目了然，为啥叫隐藏层呢，就是因为和输入输出没关系，看不见，有点儿神秘。每层的每个结点借助生物的概念称为神经元，各层之间神经元相互链接。

![](http://ww1.sinaimg.cn/mw690/780b940aly1frpn9bdowqj20un0u0tai.jpg)

算法训练包含两个阶段：输入向输出传送叫前向馈送信号，输出向输入传送叫反向误差传播。把输入前馈计算得到输出，把输出与目标值比对计算误差，把误差反向传播修正链接权重。具体过程是：

1. “输入层与隐藏层之间的链接权重”与“输入信号”加权求和，“和值”通过神经元函数（通常是阶跃函数）运算得到隐藏层的结果。
2. 用与第一步相同的过程计算出输出层的结果。
3. 目标值-输出值=误差。
4. 将误差按权重反向传播给隐藏层。
5. 用梯度下降法最小化误差，计算出误差调整值，初始误差+误差调整值=训练结果。

### 注意点
- 初始权重未知，为了避免落入错误的山谷，随机选取多个起始点（初始权重）。

- 根据调整应用在信号上的神经元函数的斜率来调整权重。

- 梯度下降法最小化误差函数。

- 训练过程就是调整权重的过程，初始权重的设定要注意避免网络饱和。初始权重过大容易导致网络饱和，初始权重为0或者相等将导致丧失学习能力。

- 输入信号通常取值范围是0.01 ~ 0.99或-1.0 ~ 1.0，一个比较合适的输出取值范围0.01 ~ 0.99。

## 问题
- 1.12节反向传播误差到更多层中，最后一张图将误差传播到了输入层，这给我造成了困惑，想了大半天，因为在后面调整误差的时候只用到了隐藏层和输出层的误差，其实在三层的网络中，只需要用输出层误差计算Who和用隐藏层误差计算Wih，计算输入层的误差其实没有用，书中应该是借用这一步推导更明确一下传播误差的方法。

- 2.4.4节wih初始化时正态分布的标准差取1/sqrt(传入链接数目)，代码中隐藏层传入链接数目用hnodes，输出层传入链接数目用onodes，我认为传入链接数目应该是上一层的结点数，所以分别应该是inodes和hnodes。

- 训练时cpu使用率40%，跑了一会以后升高到60%，临近计算结束又降到40%，不是一直跑满。

## 训练结果
MNIST手写数字识别

世代 | 隐藏层 | 隐藏层结点数 | 学习率 | 识别率 | 训练时长(s)
---|---|---|---|---|---
1 | 1 | 100 | 0.1 | 0.9479 | 24.0102
1 | 1 | 100 | 0.2 | **0.9518** | 25.4991
1 | 1 | 100 | 0.3 | 0.9443 | 26.0787
1 | 1 | 100 | 0.6 | 0.9209 | 24.9883
1 | 1 | 10 | 0.2 | **0.8495** | 11.4656
1 | 1 | 200 | 0.2 | 0.9558 | 97.4185
2 | 1 | 200 | 0.2 | 0.9574 | 49.0803
3 | 1 | 200 | 0.2 | 0.9602 | 78.7243
4 | 1 | 200 | 0.2 | 0.959 | 104.7202
5 | 1 | 200 | 0.2 | **0.9627** |146.9687
6 | 1 | 200 | 0.2 | 0.9577 | 162.4879

# 之二

## 更多隐藏层

书中分别对比了不同学习率，不同隐藏层结点数和不同训练世代的模型学习效果，没有对比多隐藏层的模型，我自己添加了一层隐藏层的代码，得出的训练结果如下：

世代 | 隐藏层 | 隐藏层结点数 | 学习率 | 识别率 | 训练时长(s)
---|---|---|---|---|---
1 | 2 | 10*10 | 0.2 | 0.7677 | 11.5368
1 | 2 | 20*20 | 0.2 | 0.8066 | 17.0215
1 | 2 | 30*30 | 0.2 | 0.8442 | 17.4176
1 | 2 | 20*30 | 0.2 | **0.7984** | 16.7845
1 | 2 | 30*20 | 0.2 | 0.8412 | 17.7463
1 | 2 | 50*50 | 0.2 | 0.8471 | 20.3632
1 | 2 | 100*100 | 0.2 | 0.8496 | 31.0611
2 | 2 | 100*100 | 0.2 | 0.8635 | 65.3597

可见多一层隐藏层学习想过不但没有提高，反而下降了。

相同训练世代相同学习率的识别率：

10 * 10 < 20 * 30 < 20 * 20 < 30 * 20 < 30 * 30 < 50 * 50

[代码](https://github.com/YngwieWang/NeuralNetwork/blob/master/annMnist_4layer.ipynb)

## 看看训练集的数字图像

把训练集的数组转换成图像，大概浏览一下手写的样子

![](http://ww1.sinaimg.cn/large/780b940aly1frqsx8rpxvj20le0j7ac7.jpg)

转换代码：
```
import numpy as np
import matplotlib.pyplot as plt


with open(r'mnist/mnist_train.csv', 'r') as datafile:
    line = datafile.readline()
    i = 1
    while line and i < 50:
        all_values = line.split(',')
        label = all_values[0]
        img_array = np.asfarray(all_values[1:]).reshape((28, 28))
        # plt.axis('off')
        plt.imshow(img_array, cmap='Greys')
        filename = 'mnist/mnist_images/test' + str(i) +\
                   '_' + label + '.png'
        plt.savefig(filename)
        i += 1
        line = datafile.readline()
```

## 更多的训练数据

MNIST有60,000条训练数据，书上为了获得更多的训练数据把每一条训练数据的图像分别顺时针、逆时针旋转了10度，这样就添加了两倍的训练样本。

世代 | 隐藏层 | 隐藏层结点数 | 学习率 | 识别率 | 训练时长(s) | 是否训练旋转数据
---|---|---|---|---|---|---
1 | 1 | 100 | 0.2 | 0.9518 | 25.4991 | 否
1 | 1 | 100 | 0.2 | 0.9471 | 70.7045 | 是
1 | 1 | 100 | 0.1 | 0.9503 | 25.7134 | 否
1 | 1 | 100 | 0.1 | 0.9544 | 70.7045 | 是
1 | 1 | 100 | 0.01 | 0.9131 | 26.4683 | 否
1 | 1 | 100 | 0.01 | 0.9329 | 72.5362 | 是
1 | 1 | 100 | 0.05 | 0.9443 | 27.1351 | 否
1 | 1 | 100 | 0.05 | 0.9519 | 73.1557 | 是
1 | 1 | 200 | 0.01 | 0.9065 | 97.4234 | 否
1 | 1 | 200 | 0.01 | 0.9338 | 296.3523 | 是
10 | 1 | 200 | 0.01 | **0.9677** | 1115.5962 | 否
10 | 1 | 200 | 0.01 | **0.9777** | 2890.7095 | 是



当学习率为0.2时，加入旋转训练数据的模型识别率反倒更低，将学习率减小为0.01以后增加旋转数据可以提高识别率，通过学习率0.01和0.05两个模型进一步判断学习率越小，增加旋转训练数据带来的学习了提高越多。但问题是很明显**训练样本增多反而导致识别率下降**。于是我怀疑我的代码有没有问题，下载了作者的代码跑，他是200个隐藏层结点、0.01的学习率跑了10个世代，github上他代码跑的结果是0.9754，我下载下来跑的是0.9779，然后我把我的代码改成一样的跑法用了2890.709569秒合48分钟，识别率是0.9777，看来没问题。然后我对比了一下10世代不用旋转数据的，识别率是0.9677，看来大样本在多世代的学习后效果才显现，另外正如书上说的，样本量大了以后可以采用更小、更谨慎的学习步长，因此将学习率减少到0.01。

另外我对比了一下我的代码和作者代码的执行效率，100个隐藏层结点0.2学习率1世代我的代码跑了71.5秒，作者的跑了74秒。


## 问题
上一篇笔记中提到初始化权重的时候正态分布方差使用的是传入链接数也就是上一层结点数，而书上用的是当前结点数，我在看github上的代码时作者已经修正为上一层结点数了。